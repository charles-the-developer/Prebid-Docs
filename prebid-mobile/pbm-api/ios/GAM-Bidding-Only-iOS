# GAM Bidding Only Integration iOS

## What this recipe covers
This recipe explains integrating the Prebid SDK and Prebid server with GAM.  
In this integration scenario:
- **Prebid SDK** and the **Prebid server** handle only the bidding and auction process.
- **GAM** and the **GMA SDK** manage the ad inventory, select the winning ad to display based on various factors, and serve the ad content to the app for rendering.  

## Prerequisites

The GAM Bidding Only Integration recipe assumes that you have the following ingredients:

- **Ad Server Account** - This is your account with an ad-serving platform, Google Ad Manager (GAM), in this integration scenario. This account allows you to manage and serve ads within your mobile app. Within this account, you'll need to configure your ad inventory and create orders to serve ads within your app. This involves defining ad units (spaces within your app where ads will be displayed) and setting up orders and line items to deliver ads to those units. After setting up your ad server account and configuring your ad inventory, you must integrate the Prebid SDK into your mobile app. This integration lets your app communicate with the ad server and participate in the header bidding process.
- **Prebid SDK** - You will need the latest version of the Prebid Mobile SDK for either [Android](https://github.com/prebid/prebid-mobile-android) or [iOS](https://github.com/prebid/prebid-mobile-ios). You also need to ensure that the SDK is initialized correctly
- **Prebid Server** - You will need a server running the [Prebid Server software](https://docs.prebid.org/prebid-server/use-cases/pbs-sdk.html). You can get one from a Prebid Server host company or set up a custom server. The Prebid Server will provide you with the following:
        - Wrapper Level Stored Request ID: - This ID is generated by the Prebid Server when it receives an ad request from your app. You won't manually obtain this ID; it's generated automatically by the Prebid Server for each ad request made by your app.
        - Ad Unit Level Stored Request ID: - Like the Wrapper Level ID, you won't manually obtain this ID; it's generated automatically by the Prebid Server for each ad unit within your app.
- **Google Mobile Ads (GMA) SDK** - This refers to the software development kit provided by your ad server (in this case, Google Ad Manager). You must ensure that you have the latest version of the Ad Server SDK supported by Prebid SDK. This SDK integration is necessary to communicate with the ad server and display ads in your app.

In summary, these prerequisites involve setting up configurations in the Prebid Server and your ad server account, integrating the Prebid SDK into your app, and ensuring compatibility with the Ad Server SDK. These steps are essential for enabling header bidding using Prebid and serving ads using GAM.

## High-level overview

The following is a high-level explanation of how the ad bidding-auction-rendering process works in this integration scenario.

![GAM Bidding Only Integration Overview](https://docs.prebid.org/assets/images/prebid-mobile/prebid-in-app-bidding-overview-prebid-original.png)

### Step 1: Initial bid request

When your mobile app wants to show an ad, the Prebid SDK sends a basic request to the Prebid Server. This request includes details about the ad space (like size and location) but not specific prices.

### Step 2: Secondary bid request

The Prebid Server takes the incomplete information received from the Prebid SDK. It adds more details to create a complete request. It then sends this request to various ad-demand partners, also known as bidders. Each bidder evaluates the request and decides whether to bid on it. If they do, they send back their bid, including the price they're willing to pay and the ad creative (the actual content like image or video to be displayed if they win).

### Step 3: Auction decision and caching

After receiving all the bids, the Prebid Server decides which one is the highest and sends that winning bid back to your app via the Prebid SDK. It also stores the ad content associated with this bid in its cache.

### Step 4: Bid details passed to ad server SDK

The Prebid SDK extracts the price bucket and other `hb_*` fields from the Prebid Server response, converts them into the targeting keywords, and passes them to the primary ad server mobile SDKâ€”the Google Mobile Ads SDK.

### Step 5: Ad request

The GMA SDK requests that an ad be displayed on Google Ad Manager (GAM). It includes the targeting key/value pair corresponding to the price bucket (bid price).

### Step 6: GAM ad source resolution

GAM resolves the competing ad sources, including the line item targeted with the key-value pair from Prebid. Suppose the line item associated with the winning bid is selected. In that case, GAM returns the creative content associated with it to the GMA SDK. 

### Step 7: Ad Rendering

The rendering begins depending on the ad type (banner, native, or video). For banners and native ads, the GMA SDK renders the ad markup using Prebid Universal Creative (PUC). For video ads, the VAST URL (a format for serving video ads) is handed off to the mobile device's video player.

### Step 8: Prebid Cache lookup

Before displaying the ad, the app checks the Prebid Cache Server to see if the creative content associated with the winning bid has been cached. If it has, the content is fetched and rendered. This step ensures that the ad loads quickly and efficiently.


## Tradeoffs and alternative approaches

The main advantage of this integration approach is that it is more flexible. As a developer, you have greater control over handling Prebid bids. Additionally, using a primary ad server increases competition. It has the potential for more significant ad revenue than approaches that don't use primary ad servers.

The major drawback, however, is that this approach requires more lines of code compared to alternatives like the rendering approach. 


## Initialization and General Parameters

The following pages provide instructions on initializing the Prebid SDK for Android and iOS and setting global parameters (used for Targeting, Privacy Consent management, etc).

[links to be added once pages are written]

## Sub-recipes

This sub-recipes section describes the integration approaches of different ad formats supported by Prebid Server.

### HTML Banner

This section describes the integration of the display banner.

To integrate HTML banner ads into the app, you should use the `BannerAdUnit` class. It is dedicated to configuring and making bid requests to the Prebid Server and providing the GMA SDK with the targeting keywords of the winning bid.

**Integration Example (Swift):**

"`swift
func created() {
        // 1. Create a BannerAdUnit
        adUnit = BannerAdUnit(configId:DM_CONFIG_ID, size: adSize)
        adUnit.setAutoRefreshMillis(time: 30000)
        
        // 2. Configure banner parameters
        let parameters = BannerParameters()
        parameters.api = [Signals.Api.MRAID_2, Signals.Api.OMID_1]
        adUnit.parameters = parameters
        
        // 3. Create a GAMBannerView
        gamBanner = GAMBannerView(adSize: GADAdSizeFromCGSize(adSize))
        gamBanner.adUnitID = DM_AD_UNIT_ID
        gamBanner.rootViewController = self
        gamBanner.delegate = self
        
        // Add GMA SDK banner view to the app UI
        bannerView?.addSubview(gamBanner)
        
        // 4. Make a bid request to Prebid Server
        let gamRequest = GAMRequest()
        adUnit.fetchDemand(adObject: gamRequest) { [weak self] resultCode in
            DemoLogger.shared.info("Prebid demand fetch for GAM \(resultCode.name())")
            
            // 5. Load GAM Ad
            self?.gamBanner.load(gamRequest)
        }
    }

```

Suppose you want to support several ad sizes. In that case, you must also implement `GADBannerViewDelegate` to adjust the banner view size according to the creative side.

"`swift
func bannerViewDidReceiveAd(_ bannerView: GADBannerView) {

    // 6. Resize ad view if needed
    AdViewUtils.findPrebidCreativeSize(bannerView, success: { size in
        guard let bannerView = bannerView as? GAMBannerView else { return }
        bannerView.resize(GADAdSizeFromCGSize(size))
    }, failure: { (error) in
       // The received ad is not Prebid's one 
    })
}
```
> [!NOTE]
> In case you use a single-size banner (as opposed to multi-size), i.e., 300x250 - you don't need to make a call to the `AdViewUtils.findPrebidCreativeSize` routine - because you already know the size of the creative (it is 300x250), however, you still need to make a call to `bannerView.resize` because the creative has the 1x1 size by default and without this call it will be rendered but as a pixel. 

> [!NOTE]
> Make sure you properly process all cases in the  `AdViewUtils.findPrebidCreativeSize` callbacks (both success and failure). Sometimes, you might not get the size of the creative (or a failure callback) - it simply means that this is not a Prebid creative. This means you still need to render the creative but don't need to resize it. At least Prebid knows nothing about it.

#### Step 1: Create a `BannerAdUnit`

Initialize the `BannerAdUnit` with the properties:

- `configId` - an ID of the Ad Unit Level Stored Request in the Prebid Server
- `adSize` - the size of the ad unit that will be used in the bid request.

If you need to bid over other ad sizes, use the `addAdditionalSize()` method to provide more relevant sizes. All of them will be added to the bid request. 

#### Step 2: Configure banner parameters

Use `BannerParameter` to customize the bid request. 

The `API` property is dedicated to signaling the supported creative frameworks to the bidder. The selected values will be added to the bid request according to the [OpenRTB 2.5](https://www.iab.com/wp-content/uploads/2016/03/OpenRTB-API-Specification-Version-2-5-FINAL.pdf) spec. GMA SDK supports creatives using the following API frameworks:

* **5** or **Signals.Api.MRAID_2** : MRAID-2 support signal
* **7** or **Signals.Api.OMID_1** :  signals OMSDK support

> _Note_: MRAID 3 is in beta so far. 


#### Step 3: Create a GAMBannerView

Follow the [GMA SDK documentation](https://developers.google.com/ad-manager/mobile-ads-sdk/ios/banner) to integrate a banner ad unit. 

#### **Step 4: Make a bid request**

The _fetchDemand_ method requests a bid from the Prebid Server. You should provide a `GAMRequest` object to this method. The Prebid SDK will set the targeting keywords of the winning bid into the provided object. Eventually, it would help if you used this object to make an ad request to GAM.

#### **Step 5: Load an Ad**

Now, you should request the ad from GAM. Suppose the `GAMRequest` contains targeting keywords. In that case, GAM will return the respective Demand Manager line item, and GMA SDK will render its creative. 

Ensure you call the _load_ method with the same `GAMRequest` object you passed to the _fetchDemand_ method in the previous step. Otherwise, the ad request will not contain targeting keywords, and Prebid's ad will never be displayed.

#### **Step 6: Adjust the ad view size**

Once an app receives a signal that an ad is loaded, you should use the `AdViewUtils.findPrebidCreativeSize` method to verify whether it's the Prebid Server's ad and resize the ad slot according to the creative's properties. 

### Video Banner (Outstream Video)

This section describes the integration of the video banner (in-feed video format)_

To integrate Video banner ads into the app, you should use the `VideoAdUnit` class. It is dedicated to configuring and making bid requests to the Demand manager and providing the GMA SDK with the targeting keywords of the winning bid.

Integration Example (Swift):

"`swift
    func created() {
        // 1. Create a VideoAdUnit
        adUnit = VideoAdUnit(configId: DM_CONFIG_ID, size: adSize)
        
        // 2. Configure video parameters
        let parameters = VideoParameters()
        parameters.mimes = ["video/mp4"]
        parameters.protocols = [Signals.Protocols.VAST_2_0]
        parameters.playbackMethod = [Signals.PlaybackMethod.AutoPlaySoundOff]
        parameters.placement = Signals.Placement.InBanner
        adUnit.parameters = parameters
        
        // 3. Create a GAMBannerView
        gamBanner = GAMBannerView(adSize: GADAdSizeFromCGSize(adSize))
        gamBanner.adUnitID = DM_AD_UNIT_ID
        gamBanner.rootViewController = self
        gamBanner.delegate = self
        
        // Add GMA SDK banner view to the app UI
        bannerView.addSubview(gamBanner)
        bannerView.backgroundColor = .clear
        
        // 4. Make a bid request to Prebid Server
        let gamRequest = GAMRequest()
        adUnit.fetchDemand(adObject: gamRequest) { [weak self] resultCode in
            DemoLogger.shared.info("Prebid demand fetch for GAM \(resultCode.name())")
            
            // 5. Load GAM Ad
            self?.gamBanner.load(gamRequest)
        }
    }
```

#### **Step 1: Create a VideoAdUnit**

Initialize the `VideoAdUnit` with properties:

- `configId` - an ID of the Ad Unit Level Stored Request on the Demand Manager

- `adSize` - the ad unit size used in the bid request.

#### **Step 2: Configure video parameters**

Using the `VideoParameters,` you can customize the bid request for `VideoAdUnit.` 

**_â€” placement_**

[OpenRTB 2.5 Placement Type](https://www.iab.com/wp-content/uploads/2016/03/OpenRTB-API-Specification-Version-2-5-FINAL.pdf) for the auction can be expressed as an integer array or can use an enum for easier readability: 

* **1** or **InStream**: In-Stream Played before, during, or after the video content the consumer has requested (e.g., Pre-roll, Mid-roll, Post-roll).
* **2** or **InBanner**: In-banner placement exists within a web banner that leverages the banner space to deliver a video experience rather than another static or rich media format. The format relies on displaying ad inventory on the page for its delivery.
* **3** or **InArticle**: In-Article placement loads and plays dynamically between paragraphs of editorial content, existing as a standalone branded message.
* **4** or **InFeed**: In-feed placement is found in content, social, or product feeds.
* **5** or **Slider**, **Floating** or **Interstitial**: Open RTB supports one of three values for option 5: Slider, Floating, or Interstitial. Suppose an enum value is supplied in placement. In that case, bidders will receive value 5 for placement type and assume it is interstitial with the install flag set to 1.

**_â€” api_**

The _api_ property is dedicated to adding values for API Frameworks to bid response according to the [OpenRTB 2.5 spec](https://www.iab.com/wp-content/uploads/2016/03/OpenRTB-API-Specification-Version-2-5-FINAL.pdf). The supported values for GMA SDK integration are:

* **5** or **Signals.Api.MRAID_2** : MRAID-2 support signal
* **7** or **Signals.Api.OMID_1**  : signals OMSDK support

**_â€” maxBitrate_**

An integer representing the OpenRTB 2.5 maximum bit rate in Kbps.

**_â€” minBitrate_**

An integer representing the OpenRTB 2.5 minimum bit rate in Kbps.

**_â€” maxDuration_**

An integer representing the OpenRTB 2.5 maximum video ad duration in seconds.

**_â€” minDuration_**

An integer representing the OpenRTB 2.5 minimum video ad duration in seconds.

**_â€” mimes_**

An array of strings representing the supported OpenRTB 2.5 content MIME types (e.g., "video/x-ms-wmv," "video/mp4").

**_â€” playbackMethod_**

Array of OpenRTB 2.5 playback methods. If none are specified, any method may be used. Only one method is typically used in practice. It is strongly advised to use only the first element of the array. 

* **1** or **Signals.PlaybackMethod.AutoPlaySoundOn** : Initiates on Page Load with Sound On
* **2** or **Signals.PlaybackMethod.AutoPlaySoundOff** : Initiates on Page Load with Sound Off by Default
* **3** or **Signals.PlaybackMethod.ClickToPlay** : Initiates on Click with Sound On
* **4** or **Signals.PlaybackMethod.MouseOver** : Initiates on Mouse-Over with Sound On
* **5** or **Signals.PlaybackMethod.EnterSoundOn** : Initiates on Entering Viewport with Sound On
* **6** or **Signals.PlaybackMethod.EnterSoundOff**: Initiates on Entering Viewport with Sound Off by Default

**_â€” protocols_**

Array or enum of OpenRTB 2.5 supported Protocols. GMA SDK, as well as IMA SDK, supports all VAST versions but not all VAST features ([details](https://developers.google.com/interactive-media-ads/docs/sdks/ios/client-side/compatibility)). So the set of protocols mostly depends on the demand partner supported formats and expected values in the request. Publishers can add the following values to the request:   

* **1** or **Signals.Protocols.VAST_1_0** : VAST 1.0
* **2** or **Signals.Protocols.VAST_2_0** : VAST 2.0
* **3** or **Signals.Protocols.VAST_3_0** : VAST 3.0
* **4** or **Signals.Protocols.VAST_1_0_Wrapper** : VAST 1.0 Wrapper
* **5** or **Signals.Protocols.VAST_2_0_Wrapper** : VAST 2.0 Wrapper
* **6** or **Signals.Protocols.VAST_3_0_Wrapper** : VAST 3.0 Wrapper
* **7** or **Signals.Protocols.VAST_4_0** : VAST 4.0
* **8** or **Signals.Protocols.VAST_4_0_Wrapper** : VAST 4.0 Wrapper

#### **Step 3: Create a GAMBannerView**

Follow the [GMA SDK documentation](https://developers.google.com/ad-manager/mobile-ads-sdk/ios/banner) to integrate the banner ad unit. 

#### **Step 4: Make a bid request**

The _fetchDemand_ method sends a bid request to the Demand Manager. You should provide a `GAMRequest` object to this method so that the Prebid SDK sets the targeting keywords of the winning bid for future ad requests. 

#### **Step 5: Load an Ad**

Now, you should request the ad from GAM. Suppose the `GAMRequest` contains targeting keywords. In that case, GAM will return the respective Prebid's line item, and GMA SDK will render its creative. 

Ensure you make the ad request with the same `GAMRequest` object you passed to the _fetchDemand_ method. Otherwise, the ad request will not contain targeting keywords, and the Demand Managers' ad will never be displayed.


### Interstitial Ads

_This section describes the integration of full-screen Interstitial ads_

You should use the `InterstitialAdUnit` class to integrate Interstitial ads into the app. It is dedicated to configuring and making bid requests to the Prebid Server and providing the GMA SDK with the targeting keywords of the winning bid.

**Integration example(Swift):**

"`swift
   func created() {
        // 1. Create an InterstitialAdUnit
        adUnit = InterstitialAdUnit(configId: DM_CONFIG_ID)
        
        // 2. Make a bid request to Prebid Server
        let gamRequest = GAMRequest()
        adUnit.fetchDemand(adObject: gamRequest) { [weak self] resultCode in
            DemoLogger.shared.info("Prebid demand fetch for GAM \(resultCode.name())")
            
            // 3. Load a GAM interstitial ad
            GAMInterstitialAd.load(withAdManagerAdUnitID: DM_AD_UNIT_ID, request: gamRequest) { ad, error in
                guard let self = self else { return }
                
                if let error = error {
                    DemoLogger.shared.error("Failed to load interstitial ad with error: \(error.localizedDescription)")
                } else if let ad = ad {
                    // 4. Present the interstitial ad
                    ad.fullScreenContentDelegate = self
                    ad.present(fromRootViewController: self)
                }
            }
        }
    }
```

#### **Step 1: Create an Ad Unit**

Initialize the Interstitial Ad Unit with properties:

    

- `configId` - an ID of the Ad Unit Level Stored Request on the Demand Manager

- `minWidthPerc` - Optional parameter to specify the minimum width percent an ad may occupy of a device's real estate. 

- `minHeightPrec`â€”An optional parameter that specifies the minimum height percent an ad may occupy of a device's real estate. 

**_How does min size percentage work_**: Demand Manager will take the screen size (width and height) as the max size for the interstitial size, generate a list of ad sizes, and select the first ten sizes that fall within the imp's max size and minimum percentage size. All the interstitial parameters will still be passed to the bidders, allowing them to use their size-matching algorithms.

**Step 2: Make a bid request**

The _fetchDemand_ method sends a bid request to the Demand Manager. You should provide a `GAMRequest` object to this method so that Prebid SDK can set the targeting keywords of the winning bid for future ad requests. 

**Step 3: Load a GAM interstitial ad**

Now, you should request the ad from GAM. Suppose the `GAMRequest` contains targeting keywords. In that case, GAM will return the respective Demand Manager line item, and GMA SDK will render its creative. 

Make the ad request with the same `GAMRequest` object you passed to the _fetchDemand_ method. Otherwise, the ad request will not contain targeting keywords, and Prebid's ad will never be displayed.

**Step 4: Present the interstitial ad**

Follow the [GMA SDK guide](https://developers.google.com/ad-manager/mobile-ads-sdk/ios/interstitial#display_the_ad) to display an interstitial ad right after receiving it or later in natural pauses in the flow of an app.


### Video Interstitial {#video-interstitial}

_This section describes the integration of full-screen VAST ads_

To integrate Video Interstitial ads into the app, you should use the `VideoInterstitialAdUnit` class. It is dedicated to configuring and making bid requests to the Demand Manager and providing the GMA SDK with the targeting keywords of the winning bid.

**Integration Example:**

"`swift
    func created() {
        // 1. Create an VideoInterstitialAdUnit
        adUnit = VideoInterstitialAdUnit(configId: DM_CONFIG_ID)
        
        // 2. Configure video parameters
        let parameters = VideoParameters()
        parameters.mimes = ["video/mp4"]
        parameters.protocols = [Signals.Protocols.VAST_2_0]
        parameters.playbackMethod = [Signals.PlaybackMethod.AutoPlaySoundOn]
        adUnit.parameters = parameters
        
        // 3. Make a bid request to Prebid Server
        let gamRequest = GAMRequest()
        adUnit.fetchDemand(adObject: gamRequest) { [weak self] resultCode in
            DemoLogger.shared.info("Prebid demand fetch for GAM \(resultCode.name())")
            
            // 4. Load a GAM interstitial ad
            GAMInterstitialAd.load(withAdManagerAdUnitID: DM_AD_UNIT_ID, request: gamRequest) { ad, error in
                guard let self = self else { return }
                if let error = error {
                    DemoLogger.shared.error("Failed to load interstitial ad with error: \(error.localizedDescription)")
                } else if let ad = ad {
                    // 5. Present the interstitial ad
                    ad.present(fromRootViewController: self)
                    ad.fullScreenContentDelegate = self
                }
            }
        }
    }
```

#### **Step 1: Create an Ad Unit**

Initialize the Interstitial `VideoInterstitialAdUnit` with properties:

- `configId` - an ID of the Ad Unit Level Stored Request on the Demand Manager

#### **Step 2: Configure video parameters**

Provide configuration properties for the video ad using the [VideoParameters](#bookmark=kix.yd1yctb1xnn7) object.

#### **Step 3: Make a bid request**

The _fetchDemand_ method makes a bid request to the prebid server. You should provide a `GAMRequest` object to this method so Prebid SDK sets the targeting keywords of the winning bid for future ad requests. 

#### **Step 4: Load a GAM interstitial ad**

Now, you should request the ad from GAM. Suppose the `GAMRequest` contains targeting keywords. In that case, GAM will return the respective Prebid's line item, and GMA SDK will render its creative. 

Ensure you make the ad request with the same `GAMRequest` object you passed to the _fetchDemand_ method. Otherwise, the ad request won't contain targeting keywords, and the Demand Manager's ad won't ever be displayed.

#### **Step 5: Present the interstitial ad**

Follow the [GMA SDK guide](https://developers.google.com/ad-manager/mobile-ads-sdk/ios/interstitial#display_the_ad) to display an interstitial ad right after receiving it or later in natural pauses in the flow of an app.


### Video Rewarded Ad

This section describes the integration of full-screen Rewarded VAST ads_

To integrate Video Interstitial ads into the app, you should use the `RewardedVideoAdUnit` class. It is dedicated to configuring and making bid requests to the Demand Manager and providing the GMA SDK with the targeting keywords of the winniMA SDK.

**Integration Example**


"`swift
    func created() {
        // 1. Create a RewardedVideoAdUnit
        adUnit = RewardedVideoAdUnit(configId: DM_CONFIG_ID)
        
        // 2. Configure video parameters
        let parameters = VideoParameters()
        parameters.mimes = ["video/mp4"]
        parameters.protocols = [Signals.Protocols.VAST_2_0]
        parameters.playbackMethod = [Signals.PlaybackMethod.AutoPlaySoundOn]
        adUnit.parameters = parameters
        
        // 3. Make a bid request to Prebid Server
        let gamRequest = GAMRequest()
        adUnit.fetchDemand(adObject: gamRequest) { [weak self] resultCode in
            DemoLogger.shared.info("Prebid demand fetch for GAM \(resultCode.name())")
            
            // 4. Load the GAM rewarded ad
            GADRewardedAd.load(withAdUnitID: DM_AD_UNIT_ID, request: gamRequest) { [weak self] ad, error in
                guard let self = self else { return }
                if let error = error {
                    DemoLogger.shared.error("Failed to load rewarded ad with error: \(error.localizedDescription)")
                } else if let ad = ad {
                    // 5. Present the interstitial ad
                    ad.fullScreenContentDelegate = self
                    ad.present(fromRootViewController: self, userDidEarnRewardHandler: {
                        _ = ad.Edward
                    })
                }
            }
        }
    }
```

#### **Step 1: Create an Ad Unit**

Initialize the `RewardedVideoAdUnit` with properties:

    

- `configId` - an ID of Stored Impression on the Demand Manager

#### **Step 2: Configure video parameters**

Provide configuration properties for the video ad using the [VideoParameters](#bookmark=kix.yd1yctb1xnn7) object.

#### **Step 3: Make a bid request**

The _fetchDemand_ method makes a bid request to the prebid server. You should provide a `GAMRequest` object to this method so Prebid SDK sets the targeting keywords of the winning bid for future ad requests. 

#### **Step 4: Load a GAM Rewarded Ad**

Now, you should request the ad from GAM. If the `GAMRequest` contains targeting keywords, GAM will return the respective Demand Manager's line item, and GMA SDK will render its creative. 

Make the ad request with the same `GAMRequest` object you passed to the _fetchDemand_ method. Otherwise, the ad request will not contain targeting keywords, and Prebid's ad will never be displayed.

#### **Step 5: Present the Rewarded Ad**

Follow the [GMA SDK guide](https://developers.google.com/ad-manager/mobile-ads-sdk/ios/rewarded#show_the_ad) to display a rewarded ad right after receiving it or later in natural pauses in an app's flow.



### Video Instream {#video-instream}

_This section describes the integration of In-Stream video_

To integrate Video banner ads into the app, you should use the `VideoAdUnit` class. It is dedicated to configuring and making bid requests to the Demand manager and providing targeting keywords of the winning bid to the [Google IMA SDK](https://developers.google.com/interactive-media-ads/docs/sdks/ios/client-side).

Integrate VideoAdUnit in the ad requesting flow.

**Integration Example (Swift):**


"`swift
// 1. Create VideoAdUnit
adUnit = VideoAdUnit(configId: DM_CONFIG_ID, size: CGSize(width: 1,height: 1))

// 2. Configure Video Parameters
let parameters = VideoParameters()
parameters.mimes = ["video/mp4"]
parameters.protocols = [Signals.Protocols.VAST_2_0]
parameters.playbackMethod = [Signals.PlaybackMethod.AutoPlaySoundOn]
adUnit.parameters = parameters

// 3. Prepare IMAAdsLoader
adsLoader = IMAAdsLoader(settings: nil)
adsLoader.delegate = self

// 4. Make a bid request
adUnit.fetchDemand { [weak self] (resultCode, prebidKeys: [String: String]?) in
    guard let self = self else { return }
    if resultCode == .prebidDemandFetchSuccess {
        do {
            
            // 5. Generate GAM Instream URI
            let adServerTag = try IMAUtils.shared.generateInstreamUriForGAM(adUnitID: GAM_AD_UNIT_ID, adSlotSizes: [.Size320x480], customKeywords: prebidKeys!)
            
            // 6. Load IMA ad request
            let adDisplayContainer = IMAAdDisplayContainer(container: self.instreamView, viewController: self)
            let request = IMAAdsRequest(adTagUrl: adServerTag, adDisplayContainer: adDisplayContainer, contentPlayhead: nil, user context: nil)
            self.adsLoader.requestAds(with: request)
        } catch {
            PrebidDemoLogger.shared.error("\(error.localizedDescription)")
            self.contentPlayer?.play()
        }
    } else {
        PrebidDemoLogger.shared.error("Error constructing IMA Tag")
        self.contentPlayer?.play()
    }
}
```

Implement  `IMAAdsLoaderDelegate`:



"`swift
func adsLoader(_ loader: IMAAdsLoader, adsLoadedWith adsLoadedData: IMAAdsLoadedData) {
    // Grab the instance of the IMAAdsManager and set ourselves as the delegate.
    adsManager = adsLoadedData.adsManager
    adsManager?.delegate = self
    
    // Initialize the ads manager.
    adsManager?.initialize(with: nil)
}

func adsLoader(_ loader: IMAAdsLoader, failedWith adErrorData: IMAAdLoadingErrorData) {
    PrebidDemoLogger.shared.error("IMA did fail with error: \(adErrorData.adError)")
    contentPlayer?.play()
}
```

Implement `IMAAdsManagerDelegate`:

"`swift
func adsManager(_ adsManager: IMAAdsManager, didReceive event: IMAAdEvent) {
    if event.type == IMAAdEventType.LOADED {
        // When the SDK notifies us that ads have been loaded, play them.
        adsManager.start()
    }
}

func adsManager(_ adsManager: IMAAdsManager, didReceive error: IMAAdError) {
    PrebidDemoLogger.shared.error("AdsManager error: \(error.message ?? "nil")")
    contentPlayer?.play()
}

func adsManagerDidRequestContentPause(_ adsManager: IMAAdsManager) {
    // The SDK will play ads, so pause the content.
    contentPlayer?.pause()
}

func adsManagerDidRequestContentResume(_ adsManager: IMAAdsManager) {
    // The SDK is done playing ads (at least for now), so resume the content.
    contentPlayer?.play()
}
```

#### **Step 1: Create an Ad Unit**

Initialize the Video Ad Unit with properties:


    - `configId` - an ID of Stored Impression on the Prebid Server


    - `size` - Width and height of the video ad unit.

#### **Step 2: Configure video parameters**

Provide configuration properties for the video ad using the [VideoParameters](#bookmark=kix.yd1yctb1xnn7) object.

#### **Step 3: Prepare IMAAdsLoader**

Prepare the in-stream setup according to [Google's docs](https://developers.google.com/interactive-media-ads/docs/sdks/ios/client-side).

#### **Step 4: Make a bid request**

The _fetchDemand_ method makes a bid request to the prebid server. You should use the version of _fetchDemand _, which returns the targeting keywords in the callback. Later, you will construct the IMA ad request using these keywords. 

#### **Step 5: Generate GAM Instream URI**

Using the Prebid util method, generate Google IMA URI for downloading the cached creative from the winning bid.

#### **Step 6: Load IMA ad request**

Create an ad display container for ad rendering. Then, create an ad request with our ad tag, display container, and optional user context and load the ad. For additional details, follow the [in-stream video guide](https://developers.google.com/interactive-media-ads/docs/sdks/ios/client-side#6_initialize_the_ads_loader_and_make_an_ads_request).  

#### **Step 7: Set up an ads loader delegate**

On a successful load event, the `IMAAdsLoader` calls the _adsLoadedWithData_ method of its assigned delegate, passing it an instance of `IMAAdsManager .`You can then initialize the ads manager, which loads the individual ads as defined by the response to the ad tag URL.

#### **Step 8: Set up an ads manager delegate**

Lastly, the ads manager needs a delegate to manage events and state changes. The `IMAAdManagerDelegate` has methods to handle ad events and errors and trigger play and pause on video content.


### Multiformat (Banner + In-App Native) 

_This section describes the integration of Multiformat ads_

The multiformat ad means the slot that can display different ad formats. In the current case, these are HTML Banner (WebView) and In-App Native (publisher-defined layout of native views like text, images, and buttons). 

In the **bidding** part, it means that the bid request should have two `imp` objects describing the particular ad format - banner and native. 

In the **displaying** part, it means that the ad should be rendered by:



* GMA SDK if the format is **banner** 
* in the publisher's custom view if the format is **native**.

From a high-level perspective, the integration consists of three steps:



1. [Configure the Native Bid Request](https://docs.google.com/document/d/1MIMo4lukYrFYO8e_WpD7x0MSLTqpY2P-U6FYasx9L28/edit#bookmark=id.wjzrt47b6mvz) 
2. [Configure and perform the ad request](#bookmark=kix.kvahbaln4hi0)
3. [Manage the Ad Response](#bookmark=kix.tm16xv5cch2w)

The following sections describe these steps in detail. 


#### Configure the Native Bid Request. 

According to the [OpenRTB protocol](https://iabtechlab.com/wp-content/uploads/2022/04/OpenRTB-2-6_FINAL.pdf), the native object in the Bid Request should contain a Request payload complying with the [Native Ad Specification](https://www.iab.com/wp-content/uploads/2018/03/OpenRTB-Native-Ads-Specification-Final-1.2.pdf). For this purpose, publishers should provide the set of native assets that confirm the ad's layout in the app. 

Prebid SDK provides API (classes) to register needed native assets:    


"`swift
private var nativeRequestAssets: [NativeAsset] {
    let title = NativeAssetTitle(length: 90, required: true)
    let body = NativeAssetData(type: DataAsset.description, required: true)
        
    let image = NativeAssetImage(minimumWidth: 120, minimumHeight: 100, required: true)
    image.type = ImageAsset.Main     
    let sponsored = NativeAssetData(type: DataAsset.sponsored, required: true)
        
    return [title, body, image, sponsored]
}
```
##### Prepare the event trackers (Optional):  {#prepare-the-event-trackers-optional}

The [Native Ad Specification](https://www.iab.com/wp-content/uploads/2018/03/OpenRTB-Native-Ads-Specification-Final-1.2.pdf) assumes that the custom event trackers are returned in the native ad. The SDK also enforces this requirement. 

"`swift
private var eventTrackers: [NativeEventTracker] {
        [NativeEventTracker(event: EventType.Impression, methods: [EventTracking.Image,EventTracking.js])]
}
```
#### Integrate the multiformat ad unit 

It would help if you used the' MultiformatdAdUnitUnit` and `PrebidRequest` cla apps to integrate multi-format ads into the app. These classes are dedicated to configuring and making multiform bid requests.

The following code snippets show the integration approach. After the code examples, a description of each integration step is provided.

Integration example(Swift):


```swift
 func created() {
        // 1. Enable adding an ID for each asset in the assets array
        Prebid.shared.shouldAssignNativeAssetID = true
        
        // 2. Setup a PrebidAdUnit
        adUnit = PrebidAdUnit(configId: DM_CONFIG_ID)
        adUnit.setAutoRefreshMillis(time: 30_000)
        
        // 3. Setup the parameters
        let bannerParameters = BannerParameters()
        bannerParameters.api = [Signals.Api.MRAID_2, Signals.Api.OMID_1]
        bannerParameters.adSizes = [adSize]
        
        let nativeParameters = NativeParameters()
        nativeParameters.assets = nativeAssets
        nativeParameters.context = ContextType.Social
        nativeParameters.placementType = PlacementType.FeedContent
        nativeParameters.contextSubType = ContextSubType.Social
        nativeParameters.eventtrackers = eventTrackers
        
        // 4. Configure the PrebidRequest
        let prebidRequest = PrebidRequest(bannerParameters: bannerParameters, nativeParameters: nativeParameters)
        
        // 5. Make a bid request
        let gamRequest = GAMRequest()
        adUnit.fetchDemand(adObject: gamRequest, request: prebidRequest) { [weak self] bidInfo in
            guard let self = self else { return }
            // 6. Configure and make a GAM ad request
            self.adLoader = GADAdLoader(adUnitID: DM_AD_UNIT_ID, rootViewController: self, adTypes: [.customNative, .gamBanner], options: [])
            self.adLoader?.delegate = self
            self.adLoader?.load(gamRequest)
        }
    }
```

##### Step 1: Enable adding an ID for each asset in the assets array

Set the `Prebid.shared.shouldAssignNativeAssetID` to `true.` This will force the SDK to add IDs for each registered native asset, which is required for Demand Manager integration.


##### Step 2: Setup a PrebidAdUnit 

Initialize the `PrebidAdUnit` with the following properties:

- **configId** - an ID of the Ad Unit Level Stored Request in the Demand Manager


##### Step 3: Setup the parameters 

For each ad format, you should create a respective configuration parameter:



* [BannerParameters](#bookmark=kix.a9mbp2l72lfc);
* [VideoParameters](#bookmark=kix.yd1yctb1xnn7);
* [NativeParameters](#bookmark=kix.wai86ic0h4hd).

Using the `NativeParameters,` you can customize the bid request for native ads:



* **assets: **the array of requested asset objects. Prebid SDK supports all kinds of assets according to the IAB spec except video;
* **eventtrackers: **the array of requested native trackers. Prebid SDK supports only image trackers according to the [IAB spec](https://iabtechlab.com/wp-content/uploads/2016/07/OpenRTB-Native-Ads-Specification-Final-1.2.pdf);
* **version: **version of the Native Markup version in use. The default value is 1.2;
* **context: **the context in which the ad appears;
* **contextSubType: **a more detailed context in which the ad appears;
* **placement type: **the design/format/layout of the ad unit being offered;
* **placementCount: **the number of identical placements in this layout;
* **sequence: **0 for the first ad, 1 for the second ad, and so on;
* **asseturlsupport: **whether the supply source/impression supports returning an assetsurl instead of an asset object. 0 or the absence of the field indicates no such support;
* **our support:** whether the supply source/impression supports returning a duo url instead of an asset object. 0 or the absence of the field indicates no such support;
* **Privacy: **set to 1 when the native ad supports buyer-specific privacy notice. Set to 0 (or field absent) when the native ad doesn't support custom privacy links or if support is unknown;
* **ext: **This object is a placeholder that may contain custom JSON agreed to by the parties to support flexibility beyond the standard defined in this specification.


##### Step 4: Configure the PrebidRequest 

Create the instance of `PrebidRequest` and initialize it with all needed ad format parameters.


##### Step 5: Make a bid request 

The `fetchDemand` method requests a bid from the Prebid Server. You should provide a `GAMRequest` object to this method so the Prebid SDK can set the targeting keywords of the winning bid for future ad requests.


##### Step 6: Configure and make a GAM ad request 

Follow the [GMA SDK documentation](https://developers.google.com/ad-manager/mobile-ads-sdk/ios/native-banner) to integrate mmultiformatads. Now, you should request the ad from GAM. Suppose the `GAMRequest` contains targeting keywords. In that case, the respective Prebid line item will be returned from GAM, and GMA SDK will render its creation. Ensure you make the ad request with the same `GAMRequest` object you passed to the `fetchDemand` method. Otherwise, the ad request won't contain targeting keywords, and Prebid's ad won't ever be displayed.
